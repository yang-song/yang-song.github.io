<!DOCTYPE html> <html> <head> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>Generative Modeling by Estimating Gradients of the Data Distribution | Yang Song</title> <meta name="author" content="Yang Song"/> <meta name="description" content="This blog post focuses on a promising new direction for generative modeling. We can learn score functions (gradients of log probability density functions) on a large number of noise-perturbed data distributions, then generate samples with Langevin-type sampling. The resulting generative models, often called <em>score-based generative models</em>, has several important advantages over existing model families: GAN-level sample quality without adversarial training, flexible model architectures, exact log-likelihood computation, and inverse problem solving without re-training models. In this blog post, we will show you in more detail the intuition, basic concepts, and potential applications of score-based generative models." /> <meta name="keywords" content="Yang Song, machine learning, AI, artificial intelligence"/> <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"/> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="none" id="highlight_theme_light"/> <link rel="shortcut icon" href="/assets/img/caltech.ico"/> <link rel="stylesheet" href="/assets/css/main.css"> <link rel="canonical" href="https://yang-song.net/blog/2021/score/"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="none" id="highlight_theme_dark"/> <script src="/assets/js/theme.js"></script> <script src="/assets/js/dark_mode.js"></script> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script src="/assets/js/distillpub/template.v2.js"></script> <script src="/assets/js/distillpub/transforms.v2.js"></script> <script src="/assets/js/distillpub/overrides.js"></script> </head> <d-front-matter> <script async type="text/json">{
      "title": "Generative Modeling by Estimating Gradients of the Data Distribution",
      "description": "This blog post focuses on a promising new direction for generative modeling. We can learn score functions (gradients of log probability density functions) on a large number of noise-perturbed data distributions, then generate samples with Langevin-type sampling. The resulting generative models, often called <em>score-based generative models</em>, has several important advantages over existing model families: GAN-level sample quality without adversarial training, flexible model architectures, exact log-likelihood computation, and inverse problem solving without re-training models. In this blog post, we will show you in more detail the intuition, basic concepts, and potential applications of score-based generative models.",
      "published": "May 5, 2021",
      "authors": [
        {
          "author": "Yang Song",
          "authorURL": "",
          "affiliations": [
            {
              "name": "Stanford University",
              "url": ""
            }
          ]
        }
        
      ],
      "katex": {
        "delimiters": [
          {
            "left": "$",
            "right": "$",
            "display": false
          },
          {
            "left": "$$",
            "right": "$$",
            "display": true
          }
        ]
      }
    }</script> </d-front-matter> <body class="fixed-top-nav"> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-bolder" href="https://yang-song.net/">Yang Song</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about</a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">publications</a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog<span class="sr-only">(current)</span></a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fas fa-moon"></i> <i class="fas fa-sun"></i> </button> </li> </ul> </div> </div> </nav> </header> <div class="post distill"> <d-title> <h1>Generative Modeling by Estimating Gradients of the Data Distribution</h1> <p>This blog post focuses on a promising new direction for generative modeling. We can learn score functions (gradients of log probability density functions) on a large number of noise-perturbed data distributions, then generate samples with Langevin-type sampling. The resulting generative models, often called <em>score-based generative models</em>, has several important advantages over existing model families: GAN-level sample quality without adversarial training, flexible model architectures, exact log-likelihood computation, and inverse problem solving without re-training models. In this blog post, we will show you in more detail the intuition, basic concepts, and potential applications of score-based generative models.</p> </d-title> <d-byline></d-byline> <d-article> <d-contents> <nav class="l-text figcaption"> <h3>Contents</h3> <div><a href="#introduction"> Introduction </a></div> <div><a href="#the-score-function-score-based-models-and-score-matching">The score function, score-based models, and score matching</a></div> <div><a href="#langevin-dynamics">Langevin dynamics</a></div> <div><a href="#naive-score-based-generative-modeling-and-its-pitfalls">Naive score-based generative modeling and its pitfalls</a></div> <div><a href="#score-based-generative-modeling-with-multiple-noise-perturbations">Score-based generative modeling with multiple noise perturbations</a></div> <div> <a href="#score-based-generative-modeling-with-stochastic-differential-equations-sdes">Score-based generative modeling with stochastic differential equations (SDEs)</a> </div> <ul> <li><a href="#perturbing-data-with-an-sde">Perturbing data with an SDE</a></li> <li><a href="#reversing-the-sde-for-sample-generation">Reversing the SDE for sample generation</a></li> <li><a href="#estimating-the-reverse-sde-with-score-based-models-and-score-matching">Estimating the reverse SDE with score-based models and score matching</a></li> <li><a href="#how-to-solve-the-reverse-sde"> How to solve the reverse SDE </a></li> <li><a href="#probability-flow-ode">Probability flow ODE</a></li> <li><a href="#controllable-generation-for-inverse-problem-solving">Controllable generation for inverse problem solving</a></li> </ul> <div><a href="#connection-to-diffusion-models-and-others">Connection to diffusion models and others</a></div> <div><a href="#concluding-remarks">Concluding remarks</a></div> </nav> </d-contents> <h2 id="introduction">Introduction</h2> <p>Existing generative modeling techniques can largely be grouped into two categories based on how they represent probability distributions.</p> <ol> <li> <strong>likelihood-based models</strong>, which directly learn the distribution’s probability density (or mass) function via (approximate) maximum likelihood. Typical likelihood-based models include autoregressive models <d-cite key="larochelle2011neural,germain2015made,van2016pixel"></d-cite>, normalizing flow models <d-cite key="dinh2014nice,dinh2016density"></d-cite>, energy-based models (EBMs)<d-cite key="lecun2006tutorial,song2021train"></d-cite>, and variational auto-encoders (VAEs) <d-cite key="kingma2013auto,rezende2014stochastic"></d-cite>.</li> <li> <strong>implicit generative models</strong> <d-cite key="mohamed2016learning"></d-cite>, where the probability distribution is implicitly represented by a model of its sampling process. The most prominent example is generative adversarial networks (GANs) <d-cite key="goodfellow2014generative"></d-cite>, where new samples from the data distribution are synthesized by transforming a random Gaussian vector with a neural network.</li> </ol> <div class="l-body"> <img class="img-fluid rounded z-depth-1" src="/assets/img/score/likelihood_based_models.png"> <figcaption style="text-align: center; margin-top: 10px; margin-bottom: 10px;"> Bayesian networks, Markov random fields (MRF), autoregressive models, and normalizing flow models are all examples of likelihood-based models. All these models represent the probability density or mass function of a distribution. </figcaption> </div> <div class="l-body"> <img class="img-fluid rounded z-depth-1" src="/assets/img/score/implicit_models.png"> <figcaption style="text-align: center; margin-top: 10px; margin-bottom: 10px;"> GAN is an example of implicit models. It implicitly represents a distribution over all objects that can be produced by the generator network. </figcaption> </div> <p>Likelihood-based models and implicit generative models, however, both have significant limitations. Likelihood-based models either require strong restrictions on the model architecture to ensure a tractable normalizing constant for likelihood computation, or must rely on surrogate objectives to approximate maximum likelihood training. Implicit generative models, on the other hand, often require adversarial training, which is notoriously unstable <d-cite key="salimans2016improved"></d-cite> and can lead to mode collapse <d-cite key="metz2017unrolled"></d-cite>.</p> <p>In this blog post, I will introduce another way to represent probability distributions that may circumvent several of these limitations. The key idea is to model <em>the gradient of the log probability density function</em>, a quantity often known as the (Stein) <strong>score function</strong> <d-cite key="chwialkowski16,liu2016kernelized"></d-cite>. Such <strong>score-based models</strong> are not required to have a tractable normalizing constant, and can be directly learned by <strong>score matching</strong> <d-cite key="hyvarinen2005estimation,vincent2011connection"></d-cite>.</p> <div class="l-page"> <img class="img-fluid rounded z-depth-1" src="/assets/img/score/score_contour.jpg" style="display: block; width: max(30%, 200px); margin-left: auto; margin-right: auto;"> <figcaption style="text-align: center; margin-top: 10px; margin-bottom: 10px;"> Score function (the vector field) and density function (contours) of a mixture of two Gaussians. </figcaption> </div> <p>Score-based models have achieved state-of-the-art performance on many downstream tasks and applications. These tasks include, among others, image generation <d-cite key="song2019generative,song2020improved,ho2020denoising,song2021scorebased,dhariwal2021diffusion,ho2021cascaded"></d-cite> (Yes, better than GANs!), audio synthesis <d-cite key="chen2021wavegrad,kong2021diffwave,popov2021grad"></d-cite>, shape generation<d-cite key="ShapeGF"></d-cite>, and music generation<d-cite key="mittal2021symbolic"></d-cite>. Moreover, score-based models have connections to <a href="https://blog.evjang.com/2018/01/nf1.html" target="_blank" rel="noopener noreferrer">normalizing flow models</a>, therefore allowing exact likelihood computation and representation learning. Additionally, modeling and estimating scores facilitates <a href="https://en.wikipedia.org/wiki/Inverse_problem#:~:text=An%20inverse%20problem%20in%20science,measurements%20of%20its%20gravity%20field" target="_blank" rel="noopener noreferrer">inverse problem</a> solving, with applications such as image inpainting <d-cite key="song2019generative,song2021scorebased"></d-cite>, image colorization <d-cite key="song2021scorebased"></d-cite>, <a href="https://en.wikipedia.org/wiki/Compressed_sensing" target="_blank" rel="noopener noreferrer">compressive sensing</a>, and medical image reconstruction (e.g., CT, MRI) <d-cite key="jalal2021robust"></d-cite>.</p> <div class="l-body"> <img class="img-fluid rounded z-depth-1" src="/assets/img/score/ffhq_samples.jpg"> <figcaption style="text-align: center; margin-top: 10px; margin-bottom: 10px;"> 1024 x 1024 samples generated from score-based models <d-cite key="song2021scorebased"></d-cite> </figcaption> </div> <p>This post aims to show you the motivation and intuition of score-based generative modeling, as well as its basic concepts, properties and applications.</p> <h2 id="the-score-function-score-based-models-and-score-matching">The score function, score-based models, and score matching</h2> <p>Suppose we are given a dataset \(\{\mathbf{x}_1, \mathbf{x}_2, \cdots, \mathbf{x}_N\}\), where each point is drawn independently from an underlying data distribution \(p(\mathbf{x})\). Given this dataset, the goal of generative modeling is to fit a model to the data distribution such that we can synthesize new data points at will by sampling from the distribution.</p> <p>In order to build such a generative model, we first need a way to represent a probability distribution. One such way, as in likelihood-based models, is to directly model the <a href="https://en.wikipedia.org/wiki/Probability_density_function" target="_blank" rel="noopener noreferrer">probability density function</a> (p.d.f.) or <a href="https://en.wikipedia.org/wiki/Probability_mass_function" target="_blank" rel="noopener noreferrer">probability mass function</a> (p.m.f.). Let \(f_\theta(\mathbf{x}) \in \mathbb{R}\) be a real-valued function parameterized by a learnable parameter \(\theta\). We can define a p.d.f. <d-footnote> Hereafter we only consider probability density functions. Probability mass functions are similar. </d-footnote> via \begin{align} p_\theta(\mathbf{x}) = \frac{e^{-f_\theta(\mathbf{x})}}{Z_\theta}, \label{ebm} \end{align} where \(Z_\theta &gt; 0\) is a normalizing constant dependent on \(\theta\), such that \(\int p_\theta(\mathbf{x}) \textrm{d} \mathbf{x} = 1\). Here the function \(f_\theta(\mathbf{x})\) is often called an unnormalized probabilistic model, or energy-based model <d-cite key="song2021train"></d-cite>.</p> <p>We can train \(p_\theta(\mathbf{x})\) by maximizing the log-likelihood of the data \begin{align} \max_\theta \sum_{i=1}^N \log p_\theta(\mathbf{x}_i). \label{mle} \end{align} However, equation \eqref{mle} requires \(p_\theta(\mathbf{x})\) to be a normalized probability density function. This is undesirable because in order to compute \(p_\theta(\mathbf{x})\), we must evaluate the normalizing constant \(Z_\theta\)—a typically intractable quantity for any general \(f_\theta(\mathbf{x})\). Thus to make maximum likelihood training feasible, likelihood-based models must either restrict their model architectures (e.g., causal convolutions in autoregressive models, invertible networks in normalizing flow models) to make \(Z_\theta\) tractable, or approximate the normalizing constant (e.g., variational inference in VAEs, or MCMC sampling used in contrastive divergence<d-cite key="hinton2002training"></d-cite>) which may be computationally expensive.</p> <p>By modeling the score function instead of the density function, we can sidestep the difficulty of intractable normalizing constants. The <strong>score function</strong> of a distribution \(p(\mathbf{x})\) is defined as \begin{equation} \nabla_\mathbf{x} \log p(\mathbf{x}), \notag \end{equation} and a model for the score function is called a <strong>score-based model</strong> <d-cite key="song2019generative"></d-cite>, which we denote as \(\mathbf{s}_\theta(\mathbf{x})\). The score-based model is learned such that \(\mathbf{s}_\theta(\mathbf{x}) \approx \nabla_\mathbf{x} \log p(\mathbf{x})\), and can be parameterized without worrying about the normalizing constant. For example, we can easily parameterize a score-based model with the energy-based model defined in equation \eqref{ebm} , via</p> \[\begin{equation} \mathbf{s}_\theta (\mathbf{x}) = \nabla_{\mathbf{x}} \log p_\theta (\mathbf{x} ) = -\nabla_{\mathbf{x}} f_\theta (\mathbf{x}) - \underbrace{\nabla_\mathbf{x} \log Z_\theta}_{=0} = -\nabla_\mathbf{x} f_\theta(\mathbf{x}). \end{equation}\] <p>Note that the score-based model \(\mathbf{s}_\theta(\mathbf{x})\) is independent of the normalizing constant \(Z_\theta\) ! This significantly expands the family of models that we can tractably use, since we don’t need any special architectures to make the normalizing constant tractable.</p> <div class="row l-body"> <div class="col-sm"> <img class="img-fluid rounded z-depth-1" src="/assets/img/score/ebm.gif"> <figcaption style="text-align: center; margin-top: 10px; margin-bottom: 10px;"> Parameterizing probability density functions. No matter how you change the model family and parameters, it has to be normalized (area under the curve must integrate to one). </figcaption> </div> <div class="col-sm"> <img class="img-fluid rounded z-depth-1" src="/assets/img/score/score.gif"> <figcaption style="text-align: center; margin-top: 10px; margin-bottom: 10px">Parameterizing score functions. No need to worry about normalization. </figcaption> </div> </div> <p>Similar to likelihood-based models, we can train score-based models by minimizing the <strong>Fisher divergence</strong> <d-footnote>Fisher divergence is typically between two distributions p and q, defined as $$\begin{equation} \mathbb{E}_{p(\mathbf{x})}[\| \nabla_\mathbf{x} \log p(\mathbf{x}) - \nabla_\mathbf{x}\log q(\mathbf{x}) \|_2^2]. \end{equation}$$ Here we slightly abuse the term as the name of a closely related expression for score-based models. </d-footnote> between the model and the data distributions, defined as \(\begin{equation} \mathbb{E}_{p(\mathbf{x})}[\| \nabla_\mathbf{x} \log p(\mathbf{x}) - \mathbf{s}_\theta(\mathbf{x}) \|_2^2]\label{fisher} \end{equation}\)</p> <p>Intuitively, the Fisher divergence compares the squared \(\ell_2\) distance between the ground-truth data score and the score-based model. Directly computing this divergence, however, is infeasible because it requires access to the unknown data score \(\nabla_\mathbf{x} \log p(\mathbf{x})\). Fortunately, there exists a family of methods called <strong>score matching</strong> <d-footnote>Commonly used score matching methods include denoising score matching <d-cite key="vincent2011connection"></d-cite> and sliced score matching <d-cite key="song2019sliced"></d-cite>. Here is an introduction to <a href="/blog/2019/ssm/">score matching and sliced score matching</a>. </d-footnote> <d-cite key="hyvarinen2005estimation,vincent2011connection,song2019sliced"></d-cite> that minimize the Fisher divergence without knowledge of the ground-truth data score. Score matching objectives can directly be estimated on a dataset and optimized with stochastic gradient descent, analogous to the log-likelihood objective for training likelihood-based models (with known normalizing constants). We can train the score-based model by minimizing a score matching objective, <strong>without requiring adversarial optimization</strong>.</p> <p>Additionally, using the score matching objective gives us a considerable amount of modeling flexibility. The Fisher divergence itself does not require \(\mathbf{s}_\theta(\mathbf{x})\) to be an actual score function of any normalized distribution—it simply compares the \(\ell_2\) distance between the ground-truth data score and the score-based model, with no additional assumptions on the form of \(\mathbf{s}_\theta(\mathbf{x})\). In fact, the only requirement on the score-based model is that it should be a vector-valued function with the same input and output dimensionality, which is easy to satisfy in practice.</p> <p>As a brief summary, we can represent a distribution by modeling its score function, which can be estimated by training a score-based model of free-form architectures with score matching.</p> <h2 id="langevin-dynamics">Langevin dynamics</h2> <p>Once we have trained a score-based model \(\mathbf{s}_\theta(\mathbf{x}) \approx \nabla_\mathbf{x} \log p(\mathbf{x})\), we can use an iterative procedure called <a href="https://en.wikipedia.org/wiki/Metropolis-adjusted_Langevin_algorithm" target="_blank" rel="noopener noreferrer"><strong>Langevin dynamics</strong></a><d-cite key="parisi1981correlation,grenander1994representations"></d-cite> to draw samples from it.</p> <p>Langevin dynamics provides an MCMC procedure to sample from a distribution \(p(\mathbf{x})\) using only its score function \(\nabla_\mathbf{x} \log p(\mathbf{x})\). Specifically, it initializes the chain from an arbitrary prior distribution \(\mathbf{x}_0 \sim \pi(\mathbf{x})\), and then iterates the following</p> \[\begin{align} \mathbf{x}_{i+1} \gets \mathbf{x}_i + \epsilon \nabla_\mathbf{x} \log p(\mathbf{x}) + \sqrt{2\epsilon}~ \mathbf{z}_i, \quad i=0,1,\cdots, K, \label{langevin} \end{align}\] <p>where \(\mathbf{z}_i \sim \mathcal{N}(0, I)\). When \(\epsilon \to 0\) and \(K \to \infty\), \(\mathbf{x}_K\) obtained from the procedure in \eqref{langevin} converges to a sample from \(p(\mathbf{x})\) under some regularity conditions. In practice, the error is negligible when \(\epsilon\) is sufficiently small and \(K\) is sufficiently large.</p> <div class="l-page"> <img class="img-fluid rounded z-depth-1" src="/assets/img/score/langevin.gif" style="display: block; width: max(30%, 300px); margin-left: auto; margin-right: auto;"> <figcaption style="text-align: center; margin-top: 10px; margin-bottom: 10px;">Using Langevin dynamics to sample from a mixture of two Gaussians. </figcaption> </div> <p>Note that Langevin dynamics accesses \(p(\mathbf{x})\) only through \(\nabla_\mathbf{x} \log p(\mathbf{x})\). Since \(\mathbf{s}_\theta(\mathbf{x}) \approx \nabla_\mathbf{x} \log p(\mathbf{x})\), we can produce samples from our score-based model \(\mathbf{s}_\theta(\mathbf{x})\) by plugging it into equation \eqref{langevin}.</p> <h2 id="naive-score-based-generative-modeling-and-its-pitfalls">Naive score-based generative modeling and its pitfalls</h2> <p>So far, we’ve discussed how to train a score-based model with score matching, and then produce samples via Langevin dynamics. However, this naive approach has had limited success in practice—we’ll talk about some pitfalls of score matching that received little attention in prior works<d-cite key="song2019generative"></d-cite>.</p> <div class="l-body"> <img class="img-fluid rounded z-depth-1" src="/assets/img/score/smld.jpg"> <figcaption style="text-align: center; margin-top: 10px; margin-bottom: 10px;"> Score-based generative modeling with score matching + Langevin dynamics. </figcaption> </div> <p>The key challenge is the fact that the estimated score functions are inaccurate in low density regions, where few data points are available for computing the score matching objective. This is expected as score matching minimizes the Fisher divergence</p> \[\mathbb{E}_{p(\mathbf{x})}[\| \nabla_\mathbf{x} \log p(\mathbf{x}) - \mathbf{s}_\theta(\mathbf{x}) \|_2^2] = \int p(\mathbf{x}) \| \nabla_\mathbf{x} \log p(\mathbf{x}) - \mathbf{s}_\theta(\mathbf{x}) \|_2^2 \mathrm{d}\mathbf{x}.\] <p>Since the \(\ell_2\) differences between the true data score function and score-based model are weighted by \(p(\mathbf{x})\), they are largely ignored in low density regions where \(p(\mathbf{x})\) is small. This behavior can lead to subpar results, as illustrated by the figure below:</p> <div class="l-body"> <img class="img-fluid rounded z-depth-1" src="/assets/img/score/pitfalls.jpg"> <figcaption style="text-align: center; margin-top: 10px; margin-bottom: 10px;"> Estimated scores are only accurate in high density regions. </figcaption> </div> <p>When sampling with Langevin dynamics, our initial sample is highly likely in low density regions when data reside in a high dimensional space. Therefore, having an inaccurate score-based model will derail Langevin dynamics from the very beginning of the procedure, preventing it from generating high quality samples that are representative of the data.</p> <h2 id="score-based-generative-modeling-with-multiple-noise-perturbations">Score-based generative modeling with multiple noise perturbations</h2> <p>How can we bypass the difficulty of accurate score estimation in regions of low data density? Our solution is to <strong>perturb</strong> data points with noise and train score-based models on the noisy data points instead. When the noise magnitude is sufficiently large, it can populate low data density regions to improve the accuracy of estimated scores. For example, here is what happens when we perturb a mixture of two Gaussians perturbed by additional Gaussian noise.</p> <div class="l-body"> <img class="img-fluid rounded z-depth-1" src="/assets/img/score/single_noise.jpg"> <figcaption style="text-align: center; margin-top: 10px; margin-bottom: 10px;"> Estimated scores are accurate everywhere for the noise-perturbed data distribution due to reduced low data density regions. </figcaption> </div> <p>Yet another question remains: how do we choose an appropriate noise scale for the perturbation process? Larger noise can obviously cover more low density regions for better score estimation, but it over-corrupts the data and alters it significantly from the original distribution. Smaller noise, on the other hand, causes less corruption of the original data distribution, but does not cover the low density regions as well as we would like.</p> <p>To achieve the best of both worlds, we use multiple scales of noise perturbations simultaneously <d-cite key="song2019generative,song2020improved"></d-cite>. Suppose we always perturb the data with isotropic Gaussian noise, and let there be a total of \(L\) increasing standard deviations \(\sigma_1 &lt; \sigma_2 &lt; \cdots &lt; \sigma_L\). We first perturb the data distribution \(p(\mathbf{x})\) with each of the Gaussian noise \(\mathcal{N}(0, \sigma_i^2 I), i=1,2,\cdots,L\) to obtain a noise-perturbed distribution</p> \[p_{\sigma_i}(\mathbf{x}) = \int p(\mathbf{y}) \mathcal{N}(\mathbf{x}; \mathbf{y}, \sigma_i^2 I) \mathrm{d} \mathbf{y}.\] <p>Note that we can easily draw samples from \(p_{\sigma_i}(\mathbf{x})\) by sampling \(\mathbf{x} \sim p(\mathbf{x})\) and computing \(\mathbf{x} + \sigma_i \mathbf{z}\), with \(\mathbf{z} \sim \mathcal{N}(0, I)\).</p> <p>Next, we estimate the score function of each noise-perturbed distribution, \(\nabla_\mathbf{x} \log p_{\sigma_i}(\mathbf{x})\), by training a <strong>Noise Conditional Score-Based Model</strong> \(\mathbf{s}_\theta(\mathbf{x}, i)\) (also called a Noise Conditional Score Network, or NCSN<d-cite key="song2019generative,song2020improved,song2021scorebased"></d-cite>, when parameterized with a neural network) with score matching, such that \(\mathbf{s}_\theta(\mathbf{x}, i) \approx \nabla_\mathbf{x} \log p_{\sigma_i}(\mathbf{x})\) for all \(i= 1, 2, \cdots, L\).</p> <div class="l-body"> <img class="img-fluid rounded z-depth-1" src="/assets/img/score/multi_scale.jpg"> <figcaption style="text-align: center; margin-top: 10px; margin-bottom: 10px;"> We apply multiple scales of Gaussian noise to perturb the data distribution (<strong>first row</strong>), and jointly estimate the score functions for all of them (<strong>second row</strong>).</figcaption> </div> <div class="l-body"> <img class="img-fluid rounded z-depth-1" src="/assets/img/score/duoduo.jpg"> <figcaption style="text-align: center; margin-top: 10px; margin-bottom: 10px"> Perturbing an image with multiple scales of Gaussian noise.</figcaption> </div> <p>The training objective for \(\mathbf{s}_\theta(\mathbf{x}, i)\) is a weighted sum of Fisher divergences for all noise scales. In particular, we use the objective below:</p> \[\begin{equation} \sum_{i=1}^L \lambda(i) \mathbb{E}_{p_{\sigma_i}(\mathbf{x})}[\| \nabla_\mathbf{x} \log p_{\sigma_i}(\mathbf{x}) - \mathbf{s}_\theta(\mathbf{x}, i) \|_2^2],\label{ncsn_obj} \end{equation}\] <p>where \(\lambda(i) \in \mathbb{R}_{&gt;0}\) is a positive weighting function, often chosen to be \(\lambda(i) = \sigma_i^2\). The objective \eqref{ncsn_obj} can be optimized with score matching, exactly as in optimizing the naive (unconditional) score-based model \(\mathbf{s}_\theta(\mathbf{x})\).</p> <p>After training our noise-conditional score-based model \(\mathbf{s}_\theta(\mathbf{x}, i)\), we can produce samples from it by running Langevin dynamics for \(i = L, L-1, \cdots, 1\) in sequence. This method is called <strong>annealed Langevin dynamics</strong> (defined by Algorithm 1 in <d-cite key="song2019generative"></d-cite>, and improved by <d-cite key="song2020improved,jolicoeur-martineau2021adversarial"></d-cite>), since the noise scale \(\sigma_i\) decreases (anneals) gradually over time.</p> <div class="l-body"> <img class="img-fluid rounded z-depth-1" src="/assets/img/score/ald.gif"> <figcaption style="text-align: center; margin-top: 10px; margin-bottom: 10px;"> Annealed Langevin dynamics combine a sequence of Langevin chains with gradually decreasing noise scales. </figcaption> </div> <div class="container"> <div class="row l-body"> <div class="col-sm"> <img class="img-fluid rounded z-depth-1" src="/assets/img/score/celeba_large.gif"> </div> <div class="col-sm"> <img class="img-fluid rounded z-depth-1" src="/assets/img/score/cifar10_large.gif"> </div> </div> <div class="row l-body"> <figcaption style="text-align: center; margin-top: 10px; margin-bottom: 10px;"> Annealed Langevin dynamics for the Noise Conditional Score Network (NCSN) model (from ref.<d-cite key="song2019generative"></d-cite>) trained on CelebA (<strong>left</strong>) and CIFAR-10 (<strong>right</strong>). We can start from unstructured noise, modify images according to the scores, and generate nice samples. The method achieved state-of-the-art Inception score on CIFAR-10 at its time. </figcaption> </div> </div> <p>Here are some practical recommendations for tuning score-based generative models with multiple noise scales:</p> <ul> <li> <p>Choose \(\sigma_1 &lt; \sigma_2 &lt; \cdots &lt; \sigma_L\) as a <a href="https://en.wikipedia.org/wiki/Geometric_progression#:~:text=In%20mathematics%2C%20a%20geometric%20progression,number%20called%20the%20common%20ratio." target="_blank" rel="noopener noreferrer">geometric progression</a>, with \(\sigma_1\) being sufficiently small and \(\sigma_L\) comparable to the maximum pairwise distance between all training data points <d-cite key="song2020improved"></d-cite>. \(L\) is typically on the order of hundreds or thousands.</p> </li> <li> <p>Parameterize the score-based model \(\mathbf{s}_\theta(\mathbf{x}, i)\) with U-Net skip connections <d-cite key="song2019generative,ho2020denoising"></d-cite>.</p> </li> <li> <p>Apply exponential moving average on the weights of the score-based model when used at test time <d-cite key="song2020improved,ho2020denoising"></d-cite>.</p> </li> </ul> <p>With such best practices, we are able to generate high quality image samples with comparable quality to GANs on various datasets, such as below:</p> <div class="l-body"> <img class="img-fluid rounded z-depth-1" src="/assets/img/score/ncsnv2.jpg"> <figcaption style="text-align: center; margin-top: 10px; margin-bottom: 10px;"> Samples from the NCSNv2<d-cite key="song2020improved"></d-cite> model. From left to right: FFHQ 256x256, LSUN bedroom 128x128, LSUN tower 128x128, LSUN church_outdoor 96x96, and CelebA 64x64.</figcaption> </div> <h2 id="score-based-generative-modeling-with-stochastic-differential-equations-sdes">Score-based generative modeling with stochastic differential equations (SDEs)</h2> <p>As we already discussed, adding multiple noise scales is critical to the success of score-based generative models. By generalizing the number of noise scales to infinity <d-cite key="song2021scorebased"></d-cite>, we obtain not only <strong>higher quality samples</strong>, but also, among others, <strong>exact log-likelihood computation</strong>, and <strong>controllable generation for inverse problem solving</strong>.</p> <p>In addition to this introduction, we have tutorials written in <a href="https://colab.research.google.com/" target="_blank" rel="noopener noreferrer">Google Colab</a> to provide a step-by-step guide for training a toy model on MNIST. We also have more advanced code repositories that provide full-fledged implementations for large scale applications.</p> <table> <thead> <tr> <th style="text-align: center">Link</th> <th style="text-align: left">Description</th> </tr> </thead> <tbody> <tr> <td style="text-align: center"><a href="https://colab.research.google.com/drive/1SeXMpILhkJPjXUaesvzEhc3Ke6Zl_zxJ?usp=sharing" target="_blank" rel="noopener noreferrer"><img src="https://colab.research.google.com/assets/colab-badge.svg" alt="Open In Colab"></a></td> <td style="text-align: left">Tutorial of score-based generative modeling with SDEs in JAX + FLAX</td> </tr> <tr> <td style="text-align: center"><a href="https://colab.research.google.com/drive/1dRR_0gNRmfLtPavX2APzUggBuXyjWW55?usp=sharing" target="_blank" rel="noopener noreferrer"><img src="https://colab.research.google.com/assets/colab-badge.svg" alt="Open In Colab"></a></td> <td style="text-align: left">Load our pretrained checkpoints and play with sampling, likelihood computation, and controllable synthesis (JAX + FLAX)</td> </tr> <tr> <td style="text-align: center"><a href="https://colab.research.google.com/drive/120kYYBOVa1i0TD85RjlEkFjaWDxSFUx3?usp=sharing" target="_blank" rel="noopener noreferrer"><img src="https://colab.research.google.com/assets/colab-badge.svg" alt="Open In Colab"></a></td> <td style="text-align: left">Tutorial of score-based generative modeling with SDEs in PyTorch</td> </tr> <tr> <td style="text-align: center"><a href="https://colab.research.google.com/drive/17lTrPLTt_0EDXa4hkbHmbAFQEkpRDZnh?usp=sharing" target="_blank" rel="noopener noreferrer"><img src="https://colab.research.google.com/assets/colab-badge.svg" alt="Open In Colab"></a></td> <td style="text-align: left">Load our pretrained checkpoints and play with sampling, likelihood computation, and controllable synthesis (PyTorch)</td> </tr> <tr> <td style="text-align: center"><a href="https://github.com/yang-song/score_sde" target="_blank" rel="noopener noreferrer">Code in JAX</a></td> <td style="text-align: left">Score SDE codebase in JAX + FLAX</td> </tr> <tr> <td style="text-align: center"><a href="https://github.com/yang-song/score_sde_pytorch" target="_blank" rel="noopener noreferrer">Code in PyTorch</a></td> <td style="text-align: left">Score SDE codebase in PyTorch</td> </tr> </tbody> </table> <h3 id="perturbing-data-with-an-sde">Perturbing data with an SDE</h3> <p>When the number of noise scales approaches infinity, we essentially perturb the data distribution with continuously growing levels of noise. In this case, the noise perturbation procedure is a continuous-time <a href="https://en.wikipedia.org/wiki/Stochastic_process#:~:text=A%20stochastic%20process%20is%20defined,measurable%20with%20respect%20to%20some" target="_blank" rel="noopener noreferrer">stochastic process</a>, as demonstrated below</p> <div class="l-body"> <img class="img-fluid rounded z-depth-1" src="/assets/img/score/perturb_vp.gif"> <figcaption style="text-align: center; margin-top: 10px; margin-bottom: 10px;"> Perturbing data to noise with a continuous-time stochastic process.</figcaption> </div> <p>How can we represent a stochastic process in a concise way? Many stochastic processes (<a href="https://en.wikipedia.org/wiki/Diffusion_process" target="_blank" rel="noopener noreferrer">diffusion processes</a> in particular) are solutions of stochastic differential equations (SDEs). In general, an SDE possesses the following form:</p> \[\begin{align} \mathrm{d}\mathbf{x} = \mathbf{f}(\mathbf{x}, t) \mathrm{d}t + g(t) \mathrm{d} \mathbf{w},\label{sde} \end{align}\] <p>where \(\mathbf{f}(\cdot, t): \mathbb{R}^d \to \mathbb{R}^d\) is a vector-valued function called the drift coefficient, \(g(t)\in \mathbb{R}\) is a real-valued function called the diffusion coefficient, \(\mathbf{w}\) denotes a standard <a href="https://en.wikipedia.org/wiki/Brownian_motion" target="_blank" rel="noopener noreferrer">Brownian motion</a>, and \(\mathrm{d} \mathbf{w}\) can be viewed as infinitesimal white noise. The solution of a stochastic differential equation is a continuous collection of random variables \(\{ \mathbf{x}(t) \}_{t\in [0, T]}\). These random variables trace stochastic trajectories as the time index \(t\) grows from the start time \(0\) to the end time \(T\). Let \(p_t(\mathbf{x})\) denote the (marginal) probability density function of \(\mathbf{x}(t)\). Here \(t \in [0, T]\) is analogous to \(i = 1, 2, \cdots, L\) when we had a finite number of noise scales, and \(p_t(\mathbf{x})\) is analogous to \(p_{\sigma_i}(\mathbf{x})\). Clearly, \(p_0(\mathbf{x}) = p(\mathbf{x})\) is the data distribution since no perturbation is applied to data at \(t=0\). After perturbing \(p(\mathbf{x})\) with the stochastic process for a sufficiently long time \(T\), \(p_T(\mathbf{x})\) becomes close to a tractable noise distribution \(\pi(\mathbf{x})\), called a <strong>prior distribution</strong>. We note that \(p_T(\mathbf{x})\) is analogous to \(p_{\sigma_L}(\mathbf{x})\) in the case of finite noise scales, which corresponds to applying the largest noise perturbation \(\sigma_L\) to the data.</p> <p>The SDE in \eqref{sde} is <strong>hand designed</strong>, similarly to how we hand-designed \(\sigma_1 &lt; \sigma_2 &lt; \cdots &lt; \sigma_L\) in the case of finite noise scales. There are numerous ways to add noise perturbations, and the choice of SDEs is not unique. For example, the following SDE</p> \[\begin{align} \mathrm{d}\mathbf{x} = e^{t} \mathrm{d} \mathbf{w} \end{align}\] <p>perturbs data with a Gaussian noise of mean zero and exponentially growing variance, which is analogous to perturbing data with \(\mathcal{N}(0, \sigma_1^2 I), \mathcal{N}(0, \sigma_2^2 I), \cdots, \mathcal{N}(0, \sigma_L^2 I)\) when \(\sigma_1 &lt; \sigma_2 &lt; \cdots &lt; \sigma_L\) is a <a href="https://en.wikipedia.org/wiki/Geometric_progression#:~:text=In%20mathematics%2C%20a%20geometric%20progression,number%20called%20the%20common%20ratio." target="_blank" rel="noopener noreferrer">geometric progression</a>. Therefore, the SDE should be viewed as part of the model, much like \(\{\sigma_1, \sigma_2, \cdots, \sigma_L\}\). In <d-cite key="song2021scorebased"></d-cite>, we provide three SDEs that generally work well for images: the Variance Exploding SDE (VE SDE), the Variance Preserving SDE (VP SDE), and the sub-VP SDE.</p> <h3 id="reversing-the-sde-for-sample-generation">Reversing the SDE for sample generation</h3> <p>Recall that with a finite number of noise scales, we can generate samples by reversing the perturbation process with <strong>annealed Langevin dynamics</strong>, i.e., sequentially sampling from each noise-perturbed distribution using Langevin dynamics. For infinite noise scales, we can analogously reverse the perturbation process for sample generation by using the reverse SDE.</p> <div class="l-body"> <img class="img-fluid rounded z-depth-1" src="/assets/img/score/denoise_vp.gif"> <figcaption style="text-align: center; margin-top: 10px; margin-bottom: 10px;"> Generate data from noise by reversing the perturbation procedure.</figcaption> </div> <p>Importantly, any SDE has a corresponding reverse SDE <d-cite key="anderson1982reverse"></d-cite>, whose closed form is given by</p> \[\begin{equation} \mathrm{d}\mathbf{x} = [\mathbf{f}(\mathbf{x}, t) - g^2(t) \nabla_\mathbf{x} \log p_t(\mathbf{x})]\mathrm{d}t + g(t) \mathrm{d} \mathbf{w}.\label{rsde} \end{equation}\] <p>Here \(\mathrm{d} t\) represents a negative infinitesimal time step, since the SDE \eqref{rsde} needs to be solved backwards in time (from \(t=T\) to \(t = 0\)). In order to compute the reverse SDE, we need to estimate \(\nabla_\mathbf{x} \log p_t(\mathbf{x})\), which is exactly the <strong>score function</strong> of \(p_t(\mathbf{x})\).</p> <div class="l-body"> <img class="img-fluid rounded z-depth-1" src="/assets/img/score/sde_schematic.jpg"> <figcaption style="text-align: center; margin-top: 10px; margin-bottom: 10px;"> Solving a reverse SDE yields a score-based generative model. Transforming data to a simple noise distribution can be accomplished with an SDE. It can be reversed to generate samples from noise if we know the score of the distribution at each intermediate time step. </figcaption> </div> <h3 id="estimating-the-reverse-sde-with-score-based-models-and-score-matching">Estimating the reverse SDE with score-based models and score matching</h3> <p>Solving the reverse SDE requires us to know the terminal distribution \(p_T(\mathbf{x})\), and the score function \(\nabla_\mathbf{x} \log p_t(\mathbf{x})\). By design, the former is close to the prior distribution \(\pi(\mathbf{x})\) which is fully tractable. In order to estimate \(\nabla_\mathbf{x} \log p_t(\mathbf{x})\), we train a <strong>Time-Dependent Score-Based Model</strong> \(\mathbf{s}_\theta(\mathbf{x}, t)\), such that \(\mathbf{s}_\theta(\mathbf{x}, t) \approx \nabla_\mathbf{x} \log p_t(\mathbf{x})\). This is analogous to the noise-conditional score-based model \(\mathbf{s}_\theta(\mathbf{x}, i)\) used for finite noise scales, trained such that \(\mathbf{s}_\theta(\mathbf{x}, i) \approx \nabla_\mathbf{x} \log p_{\sigma_i}(\mathbf{x})\).</p> <p>Our training objective for \(\mathbf{s}_\theta(\mathbf{x}, t)\) is a continuous weighted combination of Fisher divergences, given by</p> \[\begin{equation} \mathbb{E}_{t \in \mathcal{U}(0, T)}\mathbb{E}_{p_t(\mathbf{x})}[\lambda(t) \| \nabla_\mathbf{x} \log p_t(\mathbf{x}) - \mathbf{s}_\theta(\mathbf{x}, t) \|_2^2], \end{equation}\] <p>where \(\mathcal{U}(0, T)\) denotes a uniform distribution over the time interval \([0, T]\), and \(\lambda: \mathbb{R} \to \mathbb{R}_{&gt;0}\) is a positive weighting function. Typically we use \(\lambda(t) \propto 1/ \mathbb{E}[\| \nabla_{\mathbf{x}(t)} \log p(\mathbf{x}(t) \mid \mathbf{x}(0))\|_2^2]\) to balance the magnitude of different score matching losses across time.</p> <p>As before, our weighted combination of Fisher divergences can be efficiently optimized with score matching methods, such as denoising score matching <d-cite key="vincent2011connection"></d-cite> and sliced score matching <d-cite key="song2019sliced"> </d-cite>. Once our score-based model \(\mathbf{s}_\theta(\mathbf{x}, t)\) is trained to optimality, we can plug it into the expression of the reverse SDE in \eqref{rsde} to obtain an estimated reverse SDE.</p> \[\begin{equation} \mathrm{d}\mathbf{x} = [\mathbf{f}(\mathbf{x}, t) - g^2(t) \mathbf{s}_\theta(\mathbf{x}, t)]\mathrm{d}t + g(t) \mathrm{d} \mathbf{w}. \end{equation}\] <p>We can start with \(\mathbf{x}(T) \sim \pi\), and solve the above reverse SDE to obtain a sample \(\mathbf{x}(0)\). Let us denote the distribution of \(\mathbf{x}(0)\) obtained in such way as \(p_\theta\). When the score-based model \(\mathbf{s}_\theta(\mathbf{x}, t)\) is well-trained, we have \(p_\theta \approx p_0\), in which case \(\mathbf{x}(0)\) is an approximate sample from the data distribution \(p_0\).</p> <p>When \(\lambda(t) = g^2(t)\), we have an important connection between our weighted combination of Fisher divergences and the KL divergence from \(p_0\) to \(p_\theta\) under some regularity conditions <d-cite key="durkan2021maximum"></d-cite>:</p> \[\begin{multline} \operatorname{KL}(p_0(\mathbf{x})\|p_\theta(\mathbf{x})) \leq \frac{T}{2}\mathbb{E}_{t \in \mathcal{U}(0, T)}\mathbb{E}_{p_t(\mathbf{x})}[\lambda(t) \| \nabla_\mathbf{x} \log p_t(\mathbf{x}) - \mathbf{s}_\theta(\mathbf{x}, t) \|_2^2] \\+ \operatorname{KL}(p_T \mathrel\| \pi). \end{multline}\] <p>Due to this special connection to the KL divergence and the equivalence between minimizing KL divergences and maximizing likelihood for model training, we call \(\lambda(t) = g(t)^2\) the <strong>likelihood weighting function</strong>. Using this likelihood weighting function, we can train score-based generative models to achieve very high likelihoods, comparable or even superior to state-of-the-art autoregressive models<d-cite key="durkan2021maximum"></d-cite>.</p> <h3 id="how-to-solve-the-reverse-sde">How to solve the reverse SDE</h3> <p>By solving the estimated reverse SDE with numerical SDE solvers, we can simulate the reverse stochastic process for sample generation. Perhaps the simplest numerical SDE solver is the <a href="https://en.wikipedia.org/wiki/Euler%E2%80%93Maruyama_method" target="_blank" rel="noopener noreferrer">Euler-Maruyama method</a>. When applied to our estimated reverse SDE, it discretizes the SDE using finite time steps and small Gaussian noise. Specifically, it chooses a small negative time step \(\Delta t \approx 0\), initializes \(t \gets T\), and iterates the following procedure until \(t \approx 0\):</p> \[\begin{aligned} \Delta \mathbf{x} &amp;\gets [\mathbf{f}(\mathbf{x}, t) - g^2(t) \mathbf{s}_\theta(\mathbf{x}, t)]\Delta t + g(t) \sqrt{\vert \Delta t\vert }\mathbf{z}_t \\ \mathbf{x} &amp;\gets \mathbf{x} + \Delta \mathbf{x}\\ t &amp;\gets t + \Delta t, \end{aligned}\] <p>Here \(\mathbf{z}_t \sim \mathcal{N}(0, I)\). The Euler-Maruyama method is qualitatively similar to Langevin dynamics—both update \(\mathbf{x}\) by following score functions perturbed with Gaussian noise.</p> <p>Aside from the Euler-Maruyama method, other numerical SDE solvers can be directly employed to solve the reverse SDE for sample generation, including, for example, <a href="https://en.wikipedia.org/wiki/Milstein_method" target="_blank" rel="noopener noreferrer">Milstein method</a>, and <a href="https://en.wikipedia.org/wiki/Runge%E2%80%93Kutta_method_(SDE)" target="_blank" rel="noopener noreferrer">stochastic Runge-Kutta methods</a>. In <d-cite key="song2021scorebased"></d-cite>, we provided a reverse diffusion solver similar to Euler-Maruyama, but more tailored for solving reverse-time SDEs. More recently, authors in <d-cite key="jolicoeur2021gotta"></d-cite> introduced adaptive step-size SDE solvers that can generate samples faster with better quality.</p> <p>In addition, there are two special properties of our reverse SDE that allow for even more flexible sampling methods:</p> <ul> <li>We have an estimate of \(\nabla_\mathbf{x} \log p_t(\mathbf{x})\) via our time-dependent score-based model \(\mathbf{s}_\theta(\mathbf{x}, t)\).</li> <li>We only care about sampling from each marginal distribution \(p_t(\mathbf{x})\). Samples obtained at different time steps can have arbitrary correlations and do not have to form a particular trajectory sampled from the reverse SDE.</li> </ul> <p>As a consequence of these two properties, we can apply MCMC approaches to fine-tune the trajectories obtained from numerical SDE solvers. Specifically, we propose <strong>Predictor-Corrector samplers</strong>. The <strong>predictor</strong> can be any numerical SDE solver that predicts \(\mathbf{x}(t + \Delta t) \sim p_{t+\Delta t}(\mathbf{x})\) from an existing sample \(\mathbf{x}(t) \sim p_t(\mathbf{x})\). The <strong>corrector</strong> can be any MCMC procedure that solely relies on the score function, such as Langevin dynamics and Hamiltonian Monte Carlo.</p> <p>At each step of the Predictor-Corrector sampler, we first use the predictor to choose a proper step size \(\Delta t &lt; 0\), and then predict \(\mathbf{x}(t + \Delta t)\) based on the current sample \(\mathbf{x}(t)\). Next, we run several corrector steps to improve the sample \(\mathbf{x}(t + \Delta t)\) according to our score-based model \(\mathbf{s}_\theta(\mathbf{x}, t + \Delta t)\), so that \(\mathbf{x}(t + \Delta t)\) becomes a higher-quality sample from \(p_{t+\Delta t}(\mathbf{x})\).</p> <p>With Predictor-Corrector methods and better architectures of score-based models, we can achieve <strong>state-of-the-art</strong> sample quality on CIFAR-10 (measured in FID <d-cite key="FID"></d-cite> and Inception scores <d-cite key="salimans2016improved"></d-cite>), outperforming the best GAN model to date (StyleGAN2 + ADA <d-cite key="Karras2020ada"></d-cite>).</p> <table> <thead> <tr> <th style="text-align: center">Method</th> <th style="text-align: center">FID \(\downarrow\)</th> <th style="text-align: center">Inception score \(\uparrow\)</th> </tr> </thead> <tbody> <tr> <td style="text-align: center">StyleGAN2 + ADA <d-cite key="Karras2020ada"></d-cite> </td> <td style="text-align: center">2.92</td> <td style="text-align: center">9.83</td> </tr> <tr> <td style="text-align: center">Ours <d-cite key="song2021scorebased"></d-cite> </td> <td style="text-align: center"><strong>2.20</strong></td> <td style="text-align: center"><strong>9.89</strong></td> </tr> </tbody> </table> <p>The sampling methods are also scalable for extremely high dimensional data. For example, it can successfully generate high fidelity images of resolution \(1024\times 1024\).</p> <div class="l-body"> <img class="img-fluid rounded z-depth-1" src="/assets/img/score/ffhq_1024.jpeg"> <figcaption style="text-align: center; margin-top: 10px; margin-bottom: 10px;"> 1024 x 1024 samples from a score-based model trained on the FFHQ dataset. </figcaption> </div> <p>Some additional (uncurated) samples for other datasets (taken from this <a href="https://github.com/yang-song/score_sde" target="_blank" rel="noopener noreferrer">GitHub repo</a>):</p> <div class="l-body"> <img class="img-fluid rounded z-depth-1" src="/assets/img/score/bedroom.jpeg"> <figcaption style="text-align: center; margin-top: 10px; margin-bottom: 10px;"> 256 x 256 samples on LSUN bedroom. </figcaption> </div> <div class="l-body"> <img class="img-fluid rounded z-depth-1" src="/assets/img/score/celebahq_256.jpg"> <figcaption style="text-align: center; margin-top: 10px; margin-bottom: 10px;"> 256 x 256 samples on CelebA-HQ. </figcaption> </div> <h3 id="probability-flow-ode">Probability flow ODE</h3> <p>Despite capable of generating high-quality samples, samplers based on Langevin MCMC and SDE solvers do not provide a way to compute the exact log-likelihood of score-based generative models. Below, we introduce a sampler based on ordinary differential equations (ODEs) that allow for exact likelihood computation.</p> <p>In <d-cite key="song2021scorebased"></d-cite>, we show t is possible to convert any SDE into an ordinary differential equation (ODE) without changing its marginal distributions \(\{ p_t(\mathbf{x}) \}_{t \in [0, T]}\). Thus by solving this ODE, we can sample from the same distributions as the reverse SDE. The corresponding ODE of an SDE is named <strong>probability flow ODE</strong> <d-cite key="song2021scorebased"></d-cite>, given by</p> \[\begin{equation} \mathrm{d} \mathbf{x} = \bigg[\mathbf{f}(\mathbf{x}, t) - \frac{1}{2}g^2(t) \nabla_\mathbf{x} \log p_t(\mathbf{x})\bigg] \mathrm{d}t.\label{prob_ode} \end{equation}\] <p>The following figure depicts trajectories of both SDEs and probability flow ODEs. Although ODE trajectories are noticeably smoother than SDE trajectories, they convert the same data distribution to the same prior distribution and vice versa, sharing the same set of marginal distributions \(\{ p_t(\mathbf{x}) \}_{t \in [0, T]}\). In other words, trajectories obtained by solving the probability flow ODE have the same marginal distributions as the SDE trajectories.</p> <div class="l-body"> <img class="img-fluid rounded z-depth-1" src="/assets/img/score/teaser.jpg"> <figcaption style="text-align: center; margin-top: 10px; margin-bottom: 10px;"> We can map data to a noise distribution (the prior) with an SDE, and reverse this SDE for generative modeling. We can also reverse the associated probability flow ODE, which yields a deterministic process that samples from the same distribution as the SDE. Both the reverse-time SDE and probability flow ODE can be obtained by estimating score functions. </figcaption> </div> <p>This probability flow ODE formulation has several unique advantages.</p> <p>When \(\nabla_\mathbf{x} \log p_t(\mathbf{x})\) is replaced by its approximation \(\mathbf{s}_\theta(\mathbf{x}, t)\), the probability flow ODE becomes a special case of a neural ODE<d-cite key="neural_ode"></d-cite>. In particular, it is an example of continuous normalizing flows<d-cite key="grathwohl2018scalable"></d-cite>, since the probability flow ODE converts a data distribution \(p_0(\mathbf{x})\) to a prior noise distribution \(p_T(\mathbf{x})\) (since it shares the same marginal distributions as the SDE) and is fully invertible.</p> <p>As such, the probability flow ODE inherits all properties of neural ODEs or continuous normalizing flows, including exact log-likelihood computation. Specifically, we can leverage the instantaneous change-of-variable formula (Theorem 1 in <d-cite key="neural_ode"></d-cite>, Equation (4) in <d-cite key="grathwohl2018scalable"></d-cite>) to compute the unknown data density \(p_0\) from the known prior density \(p_T\) with numerical ODE solvers.</p> <p>In fact, our model achieves the <strong>state-of-the-art</strong> log-likelihoods on uniformly dequantized <d-footnote>It is typical for normalizing flow models to convert discrete images to continuous ones by adding small uniform noise to them. </d-footnote> CIFAR-10 images <d-cite key="song2021scorebased"></d-cite>, <strong>even without maximum likelihood training</strong>.</p> <table> <thead> <tr> <th style="text-align: center">Method</th> <th style="text-align: center">Negative log-likelihood (bits/dim) \(\downarrow\)</th> </tr> </thead> <tbody> <tr> <td style="text-align: center">RealNVP</td> <td style="text-align: center">3.49</td> </tr> <tr> <td style="text-align: center">iResNet</td> <td style="text-align: center">3.45</td> </tr> <tr> <td style="text-align: center">Glow</td> <td style="text-align: center">3.35</td> </tr> <tr> <td style="text-align: center">FFJORD</td> <td style="text-align: center">3.40</td> </tr> <tr> <td style="text-align: center">Flow++</td> <td style="text-align: center">3.29</td> </tr> <tr> <td style="text-align: center">Ours</td> <td style="text-align: center"><strong>2.99</strong></td> </tr> </tbody> </table> <p>When training score-based models with the <strong>likelihood weighting</strong> we discussed before, and using <strong>variational dequantization</strong> to obtain likelihoods on discrete images, we can achieve comparable or even superior likelihood to the state-of-the-art autoregressive models (all without any data augmentation) <d-cite key="durkan2021maximum"></d-cite>.</p> <table> <thead> <tr> <th style="text-align: center">Method</th> <th style="text-align: center">Negative log-likelihood (bits/dim) \(\downarrow\) on CIFAR-10</th> <th style="text-align: center">Negative log-likelihood (bits/dim) \(\downarrow\) on ImageNet 32x32</th> </tr> </thead> <tbody> <tr> <td style="text-align: center">Sparse Transformer</td> <td style="text-align: center"><strong>2.80</strong></td> <td style="text-align: center">-</td> </tr> <tr> <td style="text-align: center">Image Transformer</td> <td style="text-align: center">2.90</td> <td style="text-align: center">3.77</td> </tr> <tr> <td style="text-align: center">Ours</td> <td style="text-align: center">2.83</td> <td style="text-align: center"><strong>3.76</strong></td> </tr> </tbody> </table> <h3 id="controllable-generation-for-inverse-problem-solving">Controllable generation for inverse problem solving</h3> <p>Score-based generative models are particularly suitable for solving inverse problems. At its core, inverse problems are same as Bayesian inference problems. Let \(\mathbf{x}\) and \(\mathbf{y}\) be two random variables, and suppose we know the forward process of generating \(\mathbf{y}\) from \(\mathbf{x}\), represented by the transition probability distribution \(p(\mathbf{y} \mid \mathbf{x})\). The inverse problem is to compute \(p(\mathbf{x} \mid \mathbf{y})\). From Bayes’ rule, we have \(p(\mathbf{x} \mid \mathbf{y}) = p(\mathbf{x}) p(\mathbf{y} \mid \mathbf{x}) / \int p(\mathbf{x}) p(\mathbf{y} \mid \mathbf{x}) \mathrm{d} \mathbf{x}\). This expression can be greatly simplified by taking gradients with respect to \(\mathbf{x}\) on both sides, leading to the following Bayes’ rule for score functions:</p> \[\begin{equation} \nabla_\mathbf{x} \log p(\mathbf{x} \mid \mathbf{y}) = \nabla_\mathbf{x} \log p(\mathbf{x}) + \nabla_\mathbf{x} \log p(\mathbf{y} \mid \mathbf{x}).\label{inverse_problem} \end{equation}\] <p>Through score matching, we can train a model to estimate the score function of the unconditional data distribution, i.e., \(\mathbf{s}_\theta(\mathbf{x}) \approx \nabla_\mathbf{x} \log p(\mathbf{x})\). This will allow us to easily compute the posterior score function \(\nabla_\mathbf{x} \log p(\mathbf{x} \mid \mathbf{y})\) from the known forward process \(p(\mathbf{y} \mid \mathbf{x})\) via equation \eqref{inverse_problem}, and sample from it with Langevin-type sampling <d-cite key="song2021scorebased"></d-cite>.</p> <p>A recent work from UT Austin <d-cite key="jalal2021robust"></d-cite> has demonstrated that score-based generative models can be applied to solving inverse problems in medical imaging, such as accelerating magnetic resonance imaging (MRI). Concurrently in <d-cite key="song2022solving"></d-cite>, we demonstrated superior performance of score-based generative models not only on accelerated MRI, but also sparse-view computed tomography (CT). We were able to achieve comparable or even better performance than supervised or unrolled deep learning approaches, while being more robust to different measurement processes at test time.</p> <p>Below we show some examples on solving inverse problems for computer vision.</p> <div class="l-body"> <img class="img-fluid rounded z-depth-1 center" src="/assets/img/score/class_cond.png" style="display: block; margin-left: auto; margin-right: auto;"> <figcaption style="text-align: center; margin-top: 10px; margin-bottom: 10px;"> Class-conditional generation with an unconditional time-dependent score-based model, and a pre-trained noise-conditional image classifier on CIFAR-10. </figcaption> </div> <div class="l-body"> <img class="img-fluid rounded z-depth-1 center" src="/assets/img/score/inpainting.png" style="display: block; margin-left: auto; margin-right: auto;"> <figcaption style="text-align: center; margin-top: 10px; margin-bottom: 10px;"> Image inpainting with a time-dependent score-based model trained on LSUN bedroom. The leftmost column is ground-truth. The second column shows masked images (y in our framework). The rest columns show different inpainted images, generated by solving the conditional reverse-time SDE. </figcaption> </div> <div class="l-body"> <img class="img-fluid rounded z-depth-1 center" src="/assets/img/score/colorization.png" style="display: block; margin-left: auto; margin-right: auto;"> <figcaption style="text-align: center; margin-top: 10px; margin-bottom: 10px;"> Image colorization with a time-dependent score-based model trained on LSUN church_outdoor and bedroom. The leftmost column is ground-truth. The second column shows gray-scale images (y in our framework). The rest columns show different colorizedimages, generated by solving the conditional reverse-time SDE. </figcaption> </div> <div class="l-body"> <img class="img-fluid rounded z-depth-1 center" src="/assets/img/score/lincoln.png" style="display: block; margin-left: auto; margin-right: auto;"> <figcaption style="text-align: center; margin-top: 10px; margin-bottom: 10px;"> We can even colorize gray-scale portrays of famous people in history (Abraham Lincoln) with a time-dependent score-based model trained on FFHQ. The image resolution is 1024 x 1024.</figcaption> </div> <h2 id="connection-to-diffusion-models-and-others">Connection to diffusion models and others</h2> <p>I started working on score-based generative modeling since 2019, when I was trying hard to make score matching scalable for training deep energy-based models on high-dimensional datasets. My first attempt at this led to the method sliced score matching<d-cite key="song2019sliced"></d-cite>. Despite the scalability of sliced score matching for training energy-based models, I found to my surprise that Langevin sampling from those models fails to produce reasonable samples even on the MNIST dataset. I started investigating this issue and discovered three crucial improvements that can lead to extremely good samples: (1) perturbing data with multiple scales of noise, and training score-based models for each noise scale; (2) using a U-Net architecture (we used RefineNet since it is a modern version of U-Nets) for the score-based model; (3) applying Langevin MCMC to each noise scale and chaining them together. With those methods, I was able to obtain the state-of-the-art Inception Score on CIFAR-10 in <d-cite key="song2019generative"></d-cite> (even better than the best GANs!), and generate high-fidelity image samples of resolution up to $256\times 256$ in <d-cite key="song2020improved"></d-cite>.</p> <p>The idea of perturbing data with multiple scales of noise is by no means unique to score-based generative models though. It has been previously used in, for example, <a href="https://en.wikipedia.org/wiki/Simulated_annealing" target="_blank" rel="noopener noreferrer">simulated annealing</a>, annealed importance sampling<d-cite key="neal2001annealed"></d-cite>, diffusion probabilistic models<d-cite key="sohl2015deep"></d-cite>, infusion training<d-cite key="bordes2017learning"></d-cite>, and variational walkback<d-cite key="goyal2017variational"></d-cite> for generative stochastic networks<d-cite key="alain2016gsns"></d-cite>. Out of all these works, diffusion probabilistic modeling is perhaps the closest to score-based generative modeling. Diffusion probabilistic models are hierachical latent variable models first proposed by <a href="http://www.sohldickstein.com/" target="_blank" rel="noopener noreferrer">Jascha</a> and his colleagues <d-cite key="sohl2015deep"></d-cite> in 2015, which generate samples by learning a variational decoder to reverse a discrete diffusion process that perturbs data to noise. Without awareness of this work, score-based generative modeling was proposed and motivated independently from a very different perspective. Despite both perturbing data with multiple scales of noise, the connection between score-based generative modeling and diffusion probabilistic modeling seemed superficial at that time, since the former is trained by score matching and sampled by Langevin dynamics, while the latter is trained by the evidence lower bound (ELBO) and sampled with a learned decoder.</p> <p>In 2020, <a href="http://www.jonathanho.me/" target="_blank" rel="noopener noreferrer">Jonathan Ho</a> and colleagues <d-cite key="ho2020denoising"></d-cite> significantly improved the empirical performance of diffusion probabilistic models and first unveiled a deeper connection to score-based generative modeling. They showed that the ELBO used for training diffusion probabilistic models is essentially equivalent to the weighted combination of score matching objectives used in score-based generative modeling. Moreover, by parameterizing the decoder as a sequence of score-based models with a U-Net architecture, they demonstrated for the first time that diffusion probabilistic models can also generate high quality image samples comparable or superior to GANs.</p> <p>Inspired by their work, we further investigated the relationship between diffusion models and score-based generative models in an ICLR 2021 paper <d-cite key="song2021scorebased"></d-cite>. We found that the sampling method of diffusion probabilistic models can be integrated with annealed Langevin dynamics of score-based models to create a unified and more powerful sampler (the Predictor-Corrector sampler). By generalizing the number of noise scales to infinity, we further proved that score-based generative models and diffusion probabilistic models can both be viewed as discretizations to stochastic differential equations determined by score functions. This work bridges both score-based generative modeling and diffusion probabilistic modeling into a unified framework.</p> <p>Collectively, these latest developments seem to indicate that both score-based generative modeling with multiple noise perturbations and diffusion probabilistic models are different perspectives of the same model family, much like how <a href="https://en.wikipedia.org/wiki/Wave_mechanics" target="_blank" rel="noopener noreferrer">wave mechanics</a> and <a href="https://en.wikipedia.org/wiki/Matrix_mechanics" target="_blank" rel="noopener noreferrer">matrix mechanics</a> are equivalent formulations of quantum mechanics in the history of physics<d-footnote>Goes without saying that the significance of score-based generative models/diffusion probabilistic models is in no way comparable to quantum mechanics.</d-footnote>. The perspective of score matching and score-based models allows one to calculate log-likelihoods exactly, solve inverse problems naturally, and is directly connected to energy-based models, Schrödinger bridges and optimal transport<d-cite key="de2021diffusion"></d-cite>. The perspective of diffusion models is naturally connected to VAEs, lossy compression, and can be directly incorporated with variational probabilistic inference. This blog post focuses on the first perspective, but I highly recommend interested readers to learn about the alternative perspective of diffusion models as well (see <a href="https://lilianweng.github.io/lil-log/2021/07/11/diffusion-models.html" target="_blank" rel="noopener noreferrer">a great blog by Lilian Weng</a>).</p> <p>Many recent works on score-based generative models or diffusion probabilistic models have been deeply influenced by knowledge from both sides of research (see a <a href="https://scorebasedgenerativemodeling.github.io/" target="_blank" rel="noopener noreferrer">website</a> curated by researchers at the University of Oxford). Despite this deep connection between score-based generative models and diffusion models, it is hard to come up with an umbrella term for the model family that they both belong to. Some colleagues in DeepMind propose to call them “Generative Diffusion Processes”. It remains to be seen if this will be adopted by the community in the future.</p> <h2 id="concluding-remarks">Concluding remarks</h2> <p>This blog post gives a detailed introduction to score-based generative models. We demonstrate that this new paradigm of generative modeling is able to produce high quality samples, compute exact log-likelihoods, and perform controllable generation for inverse problem solving. It is a compilation of several papers we published in the past few years. Please visit them if you are interested in more details:</p> <ul> <li> <p><a href="https://arxiv.org/abs/1905.07088" target="_blank" rel="noopener noreferrer">Yang Song*, Sahaj Garg*, Jiaxin Shi, and Stefano Ermon. <em>Sliced Score Matching: A Scalable Approach to Density and Score Estimation</em>. UAI 2019 (Oral)</a></p> </li> <li> <p><a href="https://arxiv.org/abs/1907.05600" target="_blank" rel="noopener noreferrer">Yang Song, and Stefano Ermon. <em>Generative Modeling by Estimating Gradients of the Data Distribution</em>. NeurIPS 2019 (Oral)</a></p> </li> <li> <p><a href="https://arxiv.org/abs/2006.09011" target="_blank" rel="noopener noreferrer">Yang Song, and Stefano Ermon. <em>Improved Techniques for Training Score-Based Generative Models</em>. NeurIPS 2020</a></p> </li> <li> <p><a href="https://arxiv.org/abs/2011.13456" target="_blank" rel="noopener noreferrer">Yang Song, Jascha Sohl-Dickstein, Diederik P. Kingma, Abhishek Kumar, Stefano Ermon, and Ben Poole. <em>Score-Based Generative Modeling through Stochastic Differential Equations</em>. ICLR 2021 (Outstanding Paper Award)</a></p> </li> <li> <p><a href="https://arxiv.org/abs/2101.09258" target="_blank" rel="noopener noreferrer">Yang Song*, Conor Durkan*, Iain Murray, and Stefano Ermon. <em>Maximum Likelihood Training of Score-Based Diffusion Models</em>. NeurIPS 2021 (Spotlight)</a></p> </li> <li> <p><a href="https://arxiv.org/abs/2111.08005" target="_blank" rel="noopener noreferrer">Yang Song*, Liyue Shen*, Lei Xing, and Stefano Ermon. <em>Solving Inverse Problems in Medical Imaging with Score-Based Generative Models</em>. ICLR 2022</a></p> </li> </ul> <p>For a list of works that have been influenced by score-based generative modeling, researchers at the University of Oxford have built a very useful (but necessarily incomplete) website: <a href="https://scorebasedgenerativemodeling.github.io/" target="_blank" rel="noopener noreferrer">https://scorebasedgenerativemodeling.github.io/</a>.</p> <p>There are two major challenges of score-based generative models. First, the sampling speed is slow since it involves a large number of Langevin-type iterations. Second, it is inconvenient to work with discrete data distributions since scores are only defined on continuous distributions.</p> <p>The first challenge can be partially solved by using numerical ODE solvers for the probability flow ODE with lower precision (a similar method, denoising diffusion implicit modeling, has been proposed in <d-cite key="song2021denoising"></d-cite>). It is also possible to learn a direct mapping from the latent space of probability flow ODEs to the image space, as shown in <d-cite key="luhman2021knowledge"></d-cite>. However, all such methods to date result in worse sample quality.</p> <p>The second challenge can be addressed by learning an autoencoder on discrete data and performing score-based generative modeling on its continuous latent space <d-cite key="mittal2021symbolic,vahdat2021score"></d-cite>. Jascha’s original work on diffusion models <d-cite key="sohl2015deep"></d-cite> also provides a discrete diffusion process for discrete data distributions, but its potential for large scale applications remains yet to be proven.</p> <p>It is my conviction that these challenges will soon be solved with the joint efforts of the research community, and score-based generative models/ diffusion-based models will become one of the most useful tools for data generation, density estimation, inverse problem solving, and many other downstream tasks in machine learning.</p> </d-article> <d-appendix> <d-footnote-list></d-footnote-list> <d-citation-list></d-citation-list> </d-appendix> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2025 Yang Song. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="noopener noreferrer">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" target="_blank" rel="noopener noreferrer">al-folio</a> theme. </div> </footer> <d-bibliography src="/assets/bibliography/blogs.bib"></d-bibliography> <d-article> <div id="disqus_thread"></div> </d-article> <script type="text/javascript">var disqus_shortname="ysong",disqus_identifier="/blog/2021/score",disqus_title='"Generative Modeling by Estimating Gradients of the Data Distribution"';!function(){var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src="//"+disqus_shortname+".disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)}();</script> <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript" target="_blank" rel="noopener noreferrer">comments powered by Disqus.</a> </noscript> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=UA-69768980-1"></script> <script>function gtag(){window.dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-69768980-1");</script> </body> </html>